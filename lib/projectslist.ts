import { DataItem } from "./types";

export const projectsList: DataItem[] = [
    
    {
    id: 'meal-delivery',
    contentHtml: '<p>This is a semi-commercial meal-delivery app for demonstrations. Everybody can sign up as a regular consumer in this app. If regular consumers want to list their restaurants in the app for delivery, any user can express their intent in the app. The app administrator has the authority to approve the application. If the application is approved, the applicant will become a restaurant owner. Restaurant owners can play dual roles as restaurant owners and as regular consumers. Restaurant owners can place orders as regular users to any restaurant except for the one they manage.</p><p>The key functionalities of this app are summarized as bolow:</p><ol><li>Everybody can sign up as a regular consumer in this app.</li><li>Registered consumers can apply as restaurant owners to list their restaurants in the app for delivery. The applications need approval by the app administrator.</li><li>Restaurant owners can play dual roles as restaurant owners and as regular consumers. Restaurant owners can place orders as regular users to any restaurant except for the one they manage.</li><li>Restaurant owners have the authority to list their restaurants in the app, which still need the app administratorâ€™s approval to be officially on board.</li><li>Restaurant owners have the authority to add any meals to the restaurants they manage.</li><li>Restaurant owners can block users. The blocked users will not be able to follow the restaurants and place orders.</li><li>An order should be placed for a single restaurant only.</li><li>Once a delivery order is placed, both the placing user and the restaurant owner can instantaneously follow the delivery status. The placing users can cancel the orders if the restaurant owner does not start processing.</li><li>Regular users can track down all their purchase order records.</li><li>Restaurant owners can examine all the clients, which have placed orders at their restaurants, and their purchase order records.</li></ol><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through the <a href="https://expo.dev/@jglchen/meal-delivery">Expo Publish Link</a> with <a href="https://expo.dev/client">Expo Go</a> app.</p>',
    title: 'Meal Delivery App',
    description: 'A semi-commercial meal-delivery app for demonstrations.',
    appurl: 'https://meal-delivery-three.vercel.app',
    source: 'https://github.com/jglchen/meal-delivery',
    nativepub: 'https://exp.host/@jglchen/meal-delivery',
    nativesource: 'https://github.com/jglchen/react-native-meal-delivery',
    docker: 'docker run -p 3000:3000 jglchen/meal-delivery',
    siteimg: 'pc-meal-delivery.png',
    mobileimg: 'm-meal-delivery.png',
    priority: 220
    },    
    {
    id: 'scheduler-app',
    contentHtml: '<p>This is an appointment scheduler app for demonstrations. Once you sign up for this app, you can set up scheduled activities in the app for you. You can list the meeting targets with their email addresses and ask the app to send confirmation emails for a meeting appointment.</p><p>Users can quickly check their scheduled activities while browsing calendars, and then select a single date or date ranges to list out all the scheduled activities in the selected period.</p><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through the <a href="https://expo.dev/@jglchen/scheduler-app">Expo Publish Link</a> with <a href="https://expo.dev/client">Expo Go</a> app.</p>',
    title: 'Appointment Scheduler',
    description: 'An appointment scheduler app built with next.js for demonstrations.',
    appurl: 'https://scheduler-app-ten.vercel.app',
    source: 'https://github.com/jglchen/scheduler-app',
    nativepub: 'https://exp.host/@jglchen/scheduler-app',
    nativesource: 'https://github.com/jglchen/react-native-scheduler-app',
    docker: 'docker run -p 3000:3000 jglchen/scheduler-app',
    siteimg: 'pc-scheduler-app.png',
    mobileimg: 'm-scheduler-app.png',
    priority: 200
    },
    {
    id: 'hackernews-nextjs-apollo',
    contentHtml: '<p>This is a <a href="https://news.ycombinator.com/">Hackernews</a> clone site built with <strong>next.js</strong> implementing GraphQL APIs, for which Apollo Client is adopted in the frontend and Apollo Server in the backend server. We can successfully build a full functionality of GraphQL server with <strong>next.js</strong>, including <strong>queries</strong>, <strong>mutations</strong>, and <strong>subscriptions</strong>.</p><p>The real-time communication of subscriptions however was found not to function well once the package is deployed to Vercel, which is a serverless platform. Therefore real-time <a href="https://firebase.google.com/products/firestore">Firebase Cloud Firestore</a> is used to substitute GraphQL subscriptions.</p><p>In addition, <strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered for the clone site. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through <strong><a href="https://exp.host/@jglchen/hackernews-apollo">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'Hackernews Clone - Apollo GraphQL',
    description: 'A Hackernews clone site built with next.js implementing GraphQL APIs and Firebase Cloud Firestore to substitute GraphQL subscriptions. ',
    siteurl: 'https://hackernews-nextjs-apollo.vercel.app',
    source: 'https://github.com/jglchen/hackernews-nextjs-apollo',
    nativepub: 'https://exp.host/@jglchen/hackernews-apollo',
    nativesource: 'https://github.com/jglchen/react-native-hackernews-apollo',
    docker: 'docker run -p 3000:3000 jglchen/hackernews-nextjs-apollo',
    siteimg: 'pc-hackernews-nextjs-apollo.png',
    mobileimg: 'm-hackernews-apollo.png',
    priority: 180
    },
    {
    id: 'hackernews-nextjs-graphql-sse',
    contentHtml: '<p>This is a <a href="https://news.ycombinator.com/">Hackernews</a> clone site built with next.js implementing GraphQL APIs, for which Apollo Client is adopted in the frontend and GraphQL Yoga in the backend server.</p><p>Subscriptions are a GraphQL feature that allows a server to send data to its clients when a specific event happens. Subscriptions are usually implemented with <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-Sent Events</a>. GraphQL Yoga uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-Sent Events</a> for the subscription protocol.</p><p>The real-time communication of subscriptions however was found not to function well once the package is deployed to Vercel, which is a serverless platform. We will not deploy this package to Vercel, however, a dockerized package of this app is prepared.</p>',
    title: 'Hackernews Clone Site with GraphQL (includes GraphQL subscriptions)',
    description: 'A Hackernews clone site built with next.js implementing GraphQL APIs, for which Apollo Client is adopted in the frontend and GraphQL Yoga in the backend server. Full functionality of the GraphQL server, including queries, mutations, and subscriptions, is implemented in this app. ',
    source: 'https://github.com/jglchen/hackernews-nextjs-graphql-sse',
    docker: 'docker run -p 3000:3000 jglchen/hackernews-nextjs-graphql-sse',
    siteimg: 'pc-hackernews-nextjs-apollo.png',
    priority: 175
    },
    {
    id: 'web-scrape',
    contentHtml: '<p>This is a <strong><a href="https://nextjs.org/">next.js</a></strong> framework site to demonstrate web scraping cases and my expertise in web scraping. Totally 9 scraping cases are presented at this moment, they are handled in API routes with <strong><a href="https://nodejs.org/en/">node.js</a></strong>.</p><p>There are two main approaches to scraping the web:</p><ol><li>HTTP clients to query the web and data extraction</li><li>headless browsers</li></ol><p>For the first approach, we use <a href="https://www.npmjs.com/package/cheerio">Cheerio</a>, a library using jQuery on the server side, to crawl web pages. Sites, however, now become increasingly complex, and often regular HTTP crawling won\'t suffice anymore, but one needs a full-fledged browser engine, to get the necessary information from a site. This is particularly true for single-page applications which heavily rely on JavaScript and dynamic and asynchronous resources. Browser automation and headless browsers come to deal with the issues. Therefore we use <a href="https://pptr.dev/">Puppeteer</a> to manipulate the browser programmatically. For the cases in this demonstration, we use either way depending on the actual situations of the target pages.</p><p>In addition, <strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered for the scraping demonstrations. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through <strong><a href="https://exp.host/@jglchen/web-scraping-demonstrations">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'Web Scraping Demonstrations',
    description: 'A next.js framework site to demonstrate web scraping cases using node.js',
    siteurl: 'https://web-scrape.vercel.app',
    source: 'https://github.com/jglchen/web-scrape',
    nativepub: 'https://exp.host/@jglchen/web-scrape',
    nativesource: 'https://github.com/jglchen/react-native-web-scrape',
    docker: 'docker run -p 3000:3000 jglchen/web-scrape',
    siteimg: 'pc-web-scrape.png',
    mobileimg: 'm-web-scrape.png',
    priority: 170
    },
    {
    id: 'firebase-auth',
    contentHtml: '<p>This example creates an authentication system that uses a signed and encrypted cookie to store session data. It uses current best practices as for authentication in the Next.js ecosystem, we use <strong>useUser</strong> custom hook together with <strong><a href="https://swr.vercel.app/">SWR</a></strong> for data fetching.</p><ul><li>Firebase Authentication with Email/Password, Google Sign In, Facebook Sign In, GitHub Sign, and Email Sign available to authenticate users.</li><li>The emails registered in Firebase Authentication are saved in a separate database for future data development of individual users, for this illustration Firestore Database.</li><li>Session data is signed and encrypted in a cookie.</li></ul><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered for authentication demonstration. The apps are developed with <strong>React Native</strong>,anyone who is interested can test the apps through <strong><a href="https://expo.dev/@jglchen/firebase-auth-expo">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'Firebase Authentication Illustration',
    description: 'An authentication system with Firebase using a signed and encrypted cookie to store session data',
    siteurl: 'https://firebase-auth-rust.vercel.app',
    source: 'https://github.com/jglchen/firebase-auth',
    nativepub: 'https://exp.host/@jglchen/firebase-auth',
    nativesource: 'https://github.com/jglchen/react-native-firebase-auth',
    docker: 'docker run -p 3000:3000 jglchen/firebase-auth',
    siteimg: 'pc-firebase-auth.png',
    mobileimg: 'm-firebase-auth.png',
    priority: 160
    },
    {
    id: 'firebase-auth-email',
    contentHtml: '<p>This example creates an authentication system that uses a <strong>signed and encrypted cookie to store session data</strong>. It uses current best practices as for authentication in the Next.js ecosystem, we use <strong><code>useUser</code> custom hook</strong>  together with <a href="https://swr.vercel.app/">swr</a> for data fetching.</p><ul><li>Firebase Authentication with Email Passwordless Link is used to authenticate users.</li><li>Session data is signed and encrypted in a cookie.</li></ul><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through the <a href="https://expo.dev/@jglchen/firebase-auth-email">Expo Publish Link</a> with <a href="https://expo.dev/client">Expo Go</a> app.</p>',
    title: 'Firebase Email Passwordless Link Authentication',
    description: 'An authentication system with Firebase Email Passwordless Link using a signed and encrypted cookie to store session data.',
    siteurl: 'https://firebase-auth-email.vercel.app',
    source: 'https://github.com/jglchen/firebase-auth-email',
    nativepub: 'https://exp.host/@jglchen/firebase-auth-email',
    nativesource: 'https://github.com/jglchen/react-native-firebase-auth-email',
    docker: 'docker run -p 3000:3000 jglchen/firebase-auth-email',
    siteimg: 'pc-firebase-auth-email.png',
    mobileimg: 'm-firebase-auth-email.png',
    priority: 155
    },
    {
    id: 'firestore-realtime-chat',
    contentHtml: '<p>We can successfully build a real-time chat application with <a href="https://nextjs.org/">Next.js</a> using <a href="https://socket.io/">Socket.IO</a>. The real-time communication however was found not to function well once the package is deployed to Vercel, which is a serverless platform. It is suggested by Vercel two main approaches to applying a real-time model to stateless serverless functions.</p><ol><li>Serverless Functions have maximum execution limits and should respond as quickly as possible. They should not subscribe to data events. Instead, we need a client that subscribes to data events (such as <a href="https://ably.com/">Alby</a>, <a href="https://pusher.com/">Pusher</a>, etc.) and a serverless function that publishes new data.</li><li>Rather than pushing data, we can fetch real-time data on-demand. For example, the Vercel dashboard delivers realtime updates using <a href="https://swr.vercel.app/">SWR</a>.</li></ol><p>In this demonstration, we build a real-time chat application with <a href="https://firebase.google.com/products/firestore">Firebase Cloud FireStore</a>.</p><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through the <a href="https://expo.dev/@jglchen/firestore-realtime-chat">Expo Publish Link</a> with <a href="https://expo.dev/client">Expo Go</a> app.</p>',
    title: 'Chat Applications with Cloud Firestore',
    description: 'A real-time chat application with Next.js using Firebase Cloud FireStore',
    siteurl: 'https://firestore-realtime-chat.vercel.app',
    source: 'https://github.com/jglchen/firestore-realtime-chat',
    nativepub: 'https://exp.host/@jglchen/firestore-realtime-chat',
    nativesource: 'https://github.com/jglchen/firestore-realtime-chat-mobile',
    docker: 'docker run -p 3000:3000 jglchen/firestore-realtime-chat',
    siteimg: 'pc-firestore-realtime-chat.png',
    mobileimg: 'm-firestore-realtime-chat.png',
    priority: 140
    },
    {
    id: 'firebase-realtime-chat',
    contentHtml: '<p>We can successfully build a real-time chat application with <a href="https://nextjs.org/">Next.js</a> using <a href="https://socket.io/">Socket.IO</a>. The real-time communication however was found not to function well once the package is deployed to Vercel, which is a serverless platform. It is suggested by Vercel two main approaches to applying a real-time model to stateless serverless functions.</p><ol><li>Serverless Functions have maximum execution limits and should respond as quickly as possible. They should not subscribe to data events. Instead, we need a client that subscribes to data events (such as <a href="https://ably.com/">Alby</a>, <a href="https://pusher.com/">Pusher</a>, etc.) and a serverless function that publishes new data.</li><li>Rather than pushing data, we can fetch real-time data on-demand. For example, the Vercel dashboard delivers realtime updates using <a href="https://swr.vercel.app/">SWR</a>.</li></ol><p>In this demonstration, we build a real-time chat application with <a href="https://firebase.google.com/products/cloud-messaging">Firebase Cloud Messaging</a>. The Firebase Cloud Messaging(FCM) JavaScript API lets you receive notification messages in web apps running in browsers that support the <a href="https://www.w3.org/TR/push-api/">Push API</a>. This includes the browser versions listed in this <a href="https://caniuse.com/push-api">support matrix</a> and Chrome extensions via the Push API.</p>',
    title: 'Chat Applications with Firebase Cloud Messaging',
    description: 'A real-time chat application with Next.js using Firebase Cloud Messaging',
    siteurl: 'https://firebase-realtime-chat.vercel.app',
    source: 'https://github.com/jglchen/firebase-realtime-chat',
    docker: 'docker run -p 3000:3000 jglchen/firebase-realtime-chat',
    siteimg: 'pc-firebase-realtime-chat.png',
    priority: 135
    },
    {
    id: 'nextjs-socket-chat',
    contentHtml: '<p>There are many ways to achieve real-time content updates on the web. Long-polling, web sockets and server-side events are popular ways for real-time updates. With long-polling an HTTP request is made to the server at a predefined interval. In server-side events, the browserâ€™s event source API is used to open a channel of communication between the client and the server for updates to flow from the server to the client. The web socket protocol opens a two-way communication channel between the client and the server to allow updates to move in both ways.</p><p>This real-time chat application is built with <strong><a href="https://nextjs.org/">Next.js</a></strong> using <strong><a href="https://socket.io/">Socket.IO</a></strong> for demonstrations.</p>',
    title: 'Chat Applications with Socket.IO',
    description: 'A real-time chat application built with Next.js using Socket.IO for demonstrations',
    source: 'https://github.com/jglchen/nextjs-socket-chat',
    docker: 'docker run -p 3000:3000 jglchen/nextjs-socket-chat',
    siteimg: 'pc-nextjs-socket-chat.png',
    priority: 130
    },
    {
    id: 'realtime-stock-next',
    contentHtml: '<p>There are many ways to achieve real-time content updates on the web. Long-polling, web sockets and server-side events are popular ways for real-time updates. With long-polling an HTTP request is made to the server at a predefined interval. In server-side events, the browserâ€™s event source API is used to open a channel of communication between the client and the server for updates to flow from the server to the client. The web socket protocol opens a two-way communication channel between the client and the server to allow updates to move in both ways.</p><p>This demonstration is to leverage <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">the browser EventSource API</a></strong> to build a real-time React application.</p><ol><li>This app is designed to demonstrate real-time stock quotes. Every 10 seconds a randomly selected stock quote be updated.</li><li>In this demonstration, the updated stock prices are the direct results of random number calculation, not related to the actual price quote.</li></ol>',
    title: 'RealTime Stock Quote Demonstrations',
    description: 'The demonstration to leverage the browser EventSource API to build a real-time React application',
    source: 'https://github.com/jglchen/realtime-stock-next',
    docker: 'docker run -p 3000:3000 jglchen/realtime-stock-next',
    siteimg: 'pc-realtime-stock-next.png',
    priority: 120
    },
    {
    id: 'nextjs-projects',
    contentHtml: '<p>Next.js has two forms of pre-rendering: <strong>Static Generation</strong> and <strong>Server-side Rendering</strong>. For demonstration purposes, in this site, we predominantly employ Static Generation to pre-render pages. Therefore <strong>getStaticProps</strong> are employed to fetch the data into pages, <strong>getStaticPaths</strong> are used to generate pages with dynamic routes.</p><p>We employ <strong>the next.js framework</strong> described above to illustrate <strong>John Chen\'s</strong> side projects for publicity to show up his technical capabilities and interests.</p><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered for the personal site. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through <strong><a href="https://expo.dev/@jglchen/nextjs-projects">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'Build Applications from Website to Mobile - A Simple Server-Rendered Website with Node.js',
    description: 'A Brief Introduction of John Chen, a full-stack software developer.',
    siteurl: 'https://nextjs-projects-wheat.vercel.app',
    source: 'https://github.com/jglchen/nextjs-projects',
    nativepub: 'https://expo.dev/@jglchen/nextjs-projects',
    nativesource: 'https://github.com/jglchen/react-native-nextjs-projects',
    docker: 'docker run -p 3000:3000 jglchen/nextjs-projects',
    siteimg: 'pc-nextjs-projects.png',
    mobileimg: 'm-nextjs-projects.png',
    priority: 80
    },
    {
    id: 'react-app-demo',
    contentHtml: '<p>Demonstrate an app using fundamentals of React including simple and class components, state, props, and submitting form data to add new data or update existing records. Users can freely <strong>add</strong> characters to the table, then they can <strong>remove</strong> any character from the table or <strong>edit</strong> any specific data record.</p><p><strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through <strong><a href="https://expo.dev/@jglchen/react-app-demo">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'A React App to Demonstrate Interactive Functionality',
    description: 'Demonstrate an app using fundamentals of React including simple and class components, state, props, and submitting form data to add new data or update existing records.',
    appurl: 'https://react-app-demo-coral.vercel.app',
    source: 'https://github.com/jglchen/react-app-demo',
    nativepub: 'https://expo.dev/@jglchen/react-app-demo',
    nativesource: 'https://github.com/jglchen/react-app-demo-mobile',
    docker: 'docker run -p 3000:3000 jglchen/react-app-demo',
    siteimg: 'pc-react-app-demo.png',
    mobileimg: 'm-react-app-demo.png',
    priority: 60
    },
    {
    id: 'react-md-editor',
    contentHtml: '<p>A Markdown editor app with <strong>React.js</strong> is built to facilitate editing Markdown documents. The <strong>WYSIWYG</strong> editor allows users who may be less experienced with Markdown to use familiar toolbar buttons and shortcuts. In addition, the HTML output is shown simultaneously when editing Markdown documents.</p><p>Markdown is not a syntax that an average user will be familiar with, nor is it visually clear while editing. In other words, for an unfamiliar user, the syntax they write will make little sense until they view the result. This app has been designed to bridge this gap for non-technical users who are less familiar with or just learning Markdown syntax.</p><p><strong>Responsive web CSS designs</strong> are adopted for the app, this makes the app looks good on all devices. <strong>iOS</strong> and <strong>Android</strong> mobile apps are also delivered. The apps are developed with <strong>React Native</strong>, anyone who is interested can test the apps through <strong><a href="https://expo.dev/@jglchen/md-editor">the Expo Publish Link</a></strong> as above with <strong><a href="https://expo.dev/client">Expo Go</a></strong> app.</p>',
    title: 'React Markdown Editor',
    description: 'A Markdown editor app with React.js built to facilitate editing Markdown documents',
    appurl: 'https://react-md-editor-rho.vercel.app',
    source: 'https://github.com/jglchen/react-md-editor',
    nativepub: 'https://exp.host/@jglchen/md-editor',
    nativesource: 'https://github.com/jglchen/react-native-md-editor',
    docker: 'docker run -p 3000:3000 jglchen/react-md-editor',
    siteimg: 'pc-react-md-editor.png',
    mobileimg: 'm-react-md-editor.png',
    priority: 59
    }
];

